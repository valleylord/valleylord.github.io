
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Java 8新特性(What&#39;s New in Java 8 中文翻译版) | 褚哥说|</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="Valleylord">
    
    <meta name="description" content="本文翻译自1
前言
和很多Java开发者一样，第一次见到lambda表达式的时候，我就对它有了浓厚的兴趣；也和很多人一样，当得知它被推迟的时候，我感到很失望。不过，推迟总比没有好。
Java 8是Java语言的一大步改进，写这本书的过程强迫我学习了很多。在Lambda项目中，Java有了闭包语">
    
    
    
    
    <link rel="alternative" href="/atom.xml" title="褚哥说|" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/author.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/author.jpg">
    

	
	<link href="http://cdn.bootcss.com/highlight.js/8.2/styles/monokai.min.css" rel="stylesheet">
	<script src="http://cdn.bootcss.com/highlight.js/8.2/highlight.min.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
	

    <link rel="stylesheet" href="/css/style.css" type="text/css">


</head>

  <body>
    <header>
      <div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="褚哥说|">褚哥说|</a></h1>
				<h2 class="blog-motto">我想写一些东西</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul><li> <a href="/atom.xml">RSS</a> </li>
                    <ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/tags">标签</a></li>
					
						<li><a href="/links">链接</a></li>
					
						<li><a href="http://www.cnblogs.com/valleylord/">旧文</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
					
					</li>
                <li><div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div></li>

				</ul>
			</nav>
</div>

    </header>
    <div id="container" class="clearfix">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/post/201411-java-new-features/" title="Java 8新特性(What&#39;s New in Java 8 中文翻译版)" itemprop="url">Java 8新特性(What&#39;s New in Java 8 中文翻译版)</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://valleylord.github.io" title="Valleylord">Valleylord</a>
    </p>
  <p class="article-time">
    <time datetime="2014-11-29T05:16:00.000Z" itemprop="datePublished">2014-11-29</time>
    更新日期:<time datetime="2014-12-08T04:49:17.000Z" itemprop="dateModified">2014-12-08</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">2.</span> <span class="toc-text">1 概览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">3.</span> <span class="toc-text">2 lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">3.1.</span> <span class="toc-text">2.1 语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">3.2.</span> <span class="toc-text">2.2 范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">3.3.</span> <span class="toc-text">2.3 方法引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">3.4.</span> <span class="toc-text">2.4 函数接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">3.5.</span> <span class="toc-text">2.5 与Java 7的比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">4.</span> <span class="toc-text">3 默认方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">4.1.</span> <span class="toc-text">3.1 默认的和函数的(接口)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">4.2.</span> <span class="toc-text">3.2 多个默认方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">4.3.</span> <span class="toc-text">3.3 接口中的静态方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">5.</span> <span class="toc-text">4 Stream(流)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">5.1.</span> <span class="toc-text">4.1 什么是Stream？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">5.2.</span> <span class="toc-text">4.2 生成Stream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">5.3.</span> <span class="toc-text">4.3 For Each</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">5.4.</span> <span class="toc-text">4.4 Map/Filter/Reduce</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">5.5.</span> <span class="toc-text">4.5 Parallel Array(并行数组)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">5.6.</span> <span class="toc-text">4.6 Peek(偷看)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">5.7.</span> <span class="toc-text">4.7 Limit(限制)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">5.8.</span> <span class="toc-text">4.8 Sort(排序)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">5.9.</span> <span class="toc-text">4.9 Collector(收集器)和统计量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">5.10.</span> <span class="toc-text">4.10 分组和分块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">5.11.</span> <span class="toc-text">4.11 与Java 7的比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">6.</span> <span class="toc-text">5 Optional类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">7.</span> <span class="toc-text">6 Nashorn</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">7.1.</span> <span class="toc-text">6.1 jjs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">7.2.</span> <span class="toc-text">6.2 脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">7.3.</span> <span class="toc-text">6.3 脚本引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">7.4.</span> <span class="toc-text">6.4 引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">7.5.</span> <span class="toc-text">6.5 扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">7.6.</span> <span class="toc-text">6.6 Invocable</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">8.</span> <span class="toc-text">7 新的Date和Time API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">8.1.</span> <span class="toc-text">7.1 新的类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">8.2.</span> <span class="toc-text">7.2 创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">8.3.</span> <span class="toc-text">7.3 枚举类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">8.4.</span> <span class="toc-text">7.4 Clock(时钟)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">8.5.</span> <span class="toc-text">7.5 时间区间和时间长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">8.6.</span> <span class="toc-text">7.6 时间调整(TemporalAdjusters)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">8.7.</span> <span class="toc-text">7.7 Instant(即时)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">8.8.</span> <span class="toc-text">7.8 时区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">8.9.</span> <span class="toc-text">7.9 向后兼容性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">9.</span> <span class="toc-text">8 再也没有永久代了</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">10.</span> <span class="toc-text">9 杂项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">10.1.</span> <span class="toc-text">9.1 Base64</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">10.2.</span> <span class="toc-text">9.2 Java类型的注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">10.3.</span> <span class="toc-text">9.3 可重复的注解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">11.</span> <span class="toc-text">10 Java 8中的函数式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">11.1.</span> <span class="toc-text">10.1 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">11.2.</span> <span class="toc-text">10.2 不可变性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">11.3.</span> <span class="toc-text">10.3 并发性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">11.4.</span> <span class="toc-text">10.4 尾调用优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">12.</span> <span class="toc-text">11 结论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">13.</span> <span class="toc-text">反向移植</span></a></li></ol>
		</div>
		
		<p>本文翻译自<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p>
<h2>前言</h2>
<p>和很多Java开发者一样，第一次见到lambda表达式的时候，我就对它有了浓厚的兴趣；也和很多人一样，当得知它被推迟的时候，我感到很失望。不过，推迟总比没有好。</p>
<p>Java 8是Java语言的一大步改进，写这本书的过程强迫我学习了很多。在Lambda项目中，Java有了闭包语法、方法引用和接口的默认方法，项目规划加入了很多函数式语言的特性，并且如Java开发者期待的那样，并没有损失清晰性和简洁性。</p>
<p>除去Lambda项目，Java 8也有很多其他改动，包括新的Date和Time的API(JSR 310)、Nashorn JavaScript引擎、在HotSpot虚拟机中移除了永久代等等。</p>
<p>感谢以下作者提供了很有价值的资源：</p>
<ul>
<li>Brian Goetz – <a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-final.html" target="_blank" rel="external">Lambda综述</a></li>
<li>Aleksey Shipilev – <a href="https://github.com/shipilev/jdk8-lambda-samples" target="_blank" rel="external">jdk8 lambda示例</a></li>
<li>Richard Warburton – <a href="http://shop.oreilly.com/product/0636920030713.do" target="_blank" rel="external">Java 8 Lambdas</a></li>
<li>Julien Ponge – Oracle Nashorn, 2014年1~2月的Java Magazine 上的一篇文章</li>
<li>Venkat Subramaniam – <a href="http://blog.agiledeveloper.com/" target="_blank" rel="external">agiledeveloper.com</a></li>
<li>Java 8的所有开发人员</li>
<li>Guava、joda-time、Groovy和Scala的开发人员</li>
</ul>
<h2>1 概览</h2>
<p>本书是Java 8的简短介绍，读完后，你会对这些新特性有一个基本的了解，并可以开始使用。</p>
<p>本书假定读者已经很了解Java语言和JVM虚拟机，如果不熟悉包含Java 7在内的语言特性，书中的一些例子可能会比较困难。</p>
<p>Java 8包含以下特性：</p>
<ul>
<li>lambda表达式</li>
<li>方法引用</li>
<li>默认方法(Defender方法)</li>
<li>新的Stream API</li>
<li>Optional<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a></li>
<li>新的Date/Time API</li>
<li>新的JavaScript引擎Nashorn</li>
<li>移除永久代</li>
<li>其他</li>
</ul>
<p>阅读本书的最好办法是打开一个支持Java 8的IDE来试试这些新特性。</p>
<blockquote>
<p>代码示例在<a href="https://github.com/adamd/hellojava8" target="_blank" rel="external">这里</a></p>
</blockquote>
<h2>2 lambda表达式</h2>
<p>Java 8最大的新特性就是语言级的支持了<em>lambda表达式</em>(Lambda项目)。lambda表达式很像包含一个自动推断类型方法的匿名类的语法糖<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>，然而对于简化开发有重大意义。</p>
<h3>2.1 语法</h3>
<p>lambda表达式的主要语法是：参数-&gt;方法体。编译器通常可以根据lambda表达式的上下文，来确定使用的函数接口<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>和参数类型。这个语法中有4个重要规则：</p>
<ul>
<li>声明参数的类型是非强制的；</li>
<li>如果只有一个参数，那么参数外的括号()是非强制的；</li>
<li>使用大括号{}是非强制的(除非需要使用多个语句)；</li>
<li>如果只有一个语句返回一个结果，那么<code>return</code>关键字是非强制的。</li>
</ul>
<p>这里是一些语法的示例：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">() -&gt; System.out.println(<span class="keyword">this</span>)</div><div class="line">(String str) -&gt; System.out.println(str)</div><div class="line">str -&gt; System.out.println(str)</div><div class="line">(String s1, String s2) -&gt; { <span class="keyword">return</span> s2.length() - s1.length(); }</div><div class="line">(s1, s2) -&gt; s2.length() - s1.length()</div></pre></td></tr></table></figure></p>
<p>最后一个表达式可以用来做list的排序，如下：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Arrays.sort(strArray, </div><div class="line">  (String s1, String s2) -&gt; s2.length() - s1.length());</div></pre></td></tr></table></figure></p>
<p>在此例中，lambda表达式实现了<code>Comparator</code>接口来按长度排序字符串。</p>
<h3>2.2 范围</h3>
<p>这是一个使用lambda及Runnable接口的短例：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.out;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>{</div><div class="line">	Runnable r1 = () -&gt; out.println(<span class="keyword">this</span>);</div><div class="line">	Runnable r2 = () -&gt; out.println(toString());</div><div class="line"></div><div class="line">	<span class="keyword">public</span> String <span class="title">toString</span>() { <span class="keyword">return</span> <span class="string">"Hello, world!"</span>; }</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String... args) {</div><div class="line">		<span class="keyword">new</span> Hello().r1.run(); <span class="comment">//Hello, world!</span></div><div class="line">		<span class="keyword">new</span> Hello().r2.run(); <span class="comment">//Hello, world!</span></div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>值得关注的是<code>r1</code>和<code>r2</code>两个lambda调用<code>Hello</code>类的<code>toStrin()</code>方法，这展示了lambda可用的范围。</p>
<p>也可以引用常量或<em>实际上</em>的常量(effectively final variables)，变量如果只被赋值一次，就是实际上的常量。</p>
<p>例如，使用Spring的Hibernate模板：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String sql = <span class="string">"delete * from User"</span>;</div><div class="line">getHibernateTemplate().execute(session -&gt; </div><div class="line">    session.createSQLQuery(sql).uniqueResult());</div></pre></td></tr></table></figure></p>
<p>以上代码中，你可以引用变量<code>sql</code>因为它只被赋值了一次，如果它再被赋值一次的话，就会导致编译错误。</p>
<h3>2.3 方法引用</h3>
<p>lambda表达式类似一个非对象的方法，如果我们可以引用已有方法来替代lambda表达式岂非更好？这正是<em>方法引用</em>所能做的。</p>
<p>例如，如果你需要经常根据文件的类型来过滤一系列文件，假定你已有以下一些用于确定文件类型的方法：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileFilters</span> </span>{</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">fileIsPdf</span>(File file) {<span class="comment">/*code*/</span>}</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">fileIsTxt</span>(File file) {<span class="comment">/*code*/</span>}</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">fileIsRtf</span>(File file) {<span class="comment">/*code*/</span>}</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>在需要过滤文件的时候，你可以用方法引用，如下例所示(假设已经定义了方法<code>getFiles</code>返回<code>Stream</code>)：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Stream&lt;File&gt; pdfs = getFiles().filter(FileFilters::fileIsPdf);</div><div class="line">Stream&lt;File&gt; txts = getFiles().filter(FileFilters::fileIsTxt);</div><div class="line">Stream&lt;File&gt; rtfs = getFiles().filter(FileFilters::fileIsRtf);</div></pre></td></tr></table></figure></p>
<p>方法引用可以指向：</p>
<ul>
<li>静态方法</li>
<li>实例方法</li>
<li><em>特定</em>实例上的方法</li>
<li>构造器(如，<code>TreeSet::new</code>)</li>
</ul>
<p>例如，使用新的<code>java.nio.file.Files.lines</code>方法：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Files.lines(Paths.get(<span class="string">"Nio.java"</span>))</div><div class="line">         .map(String::trim)</div><div class="line">         .forEach(System.out::println);</div></pre></td></tr></table></figure></p>
<p>以上代码读入文件&quot;Nio.java&quot;，对每一行调用<code>trim()</code>，并打印每一行。</p>
<p>注意，<code>System.out::println</code>表示<code>PrintStream</code>实例的<code>println</code>方法。</p>
<h3>2.4 函数接口</h3>
<p>Java 8中定义的<em>函数接口</em>是仅包含一个抽象方法的接口，这对之前版本的Java中添加的接口也有效。</p>
<p>Java 8在<code>java.util.function</code>包中引入了一些新的函数接口。</p>
<ul>
<li>Function<t,r> - 输入T类型的对象返回R类型的对象。</t,r></li>
<li>Supplier<t> - 仅返回T类型对象。</t></li>
<li>Predicate<t> - 根据T类型的输入返回布尔值。</t></li>
<li>Consumer<t> - 根据T类型的输入执行操作。</t></li>
<li>BiFunction - 和Function类似，但有2个参数。</li>
<li>BiConsumer - 和Consumer类似，但有2个参数。</li>
</ul>
<p>它也为基础类型引入了一些派生的接口，例如：</p>
<ul>
<li>IntConsumer</li>
<li>IntFunction<r></r></li>
<li>IntPredicate</li>
<li>IntSupplier</li>
</ul>
<blockquote>
<p>更多信息请参考<a href="http://download.java.net/jdk8/docs/api/java/util/function/package-summary.html" target="_blank" rel="external">java.util.function Javadocs</a></p>
</blockquote>
<p>函数接口最屌的是可以用任何能完成其职责的对象来赋值给它，正如以下代码示例，</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Function&lt;String, String&gt; atr = (name) -&gt; {<span class="keyword">return</span> <span class="string">"@"</span> + name;};</div><div class="line">Function&lt;String, Integer&gt; leng = (name) -&gt; name.length();</div><div class="line">Function&lt;String, Integer&gt; leng2 = String::length;</div></pre></td></tr></table></figure></p>
<p>这些代码在Java 8中是完全合法的，第一行定义了在String前插入'@'的函数；后两行是相同的，定义了获取String长度的函数。</p>
<p>Java编译器已经足够聪明到可以将String的<code>length()</code>的方法引用转换为<code>Function</code>(函数接口)，其<code>apply</code>方法输入String并返回Integer。例如：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (String s : args) out.println(leng2.apply(s));</div></pre></td></tr></table></figure></p>
<p>会打印所有输入字符串的长度。</p>
<p>任意接口都可以是函数接口，而不仅仅是哪些由Java引入的方法。可以使用注解<code>@FunctionalInterface</code>来表示你认为一个接口是函数接口。尽管不必要，如果你的接口不满足要求(如，只有一个抽象方法)，将会导致编译错误。</p>
<blockquote>
<p><strong>Github</strong></p>
</blockquote>
<blockquote>
<p>更多例子请参考jdk8 lambda示例</p>
</blockquote>
<h3>2.5 与Java 7的比较</h3>
<p>为了更好的阐述lambda表达式的优势，这里的一些例子展示了如何在Java 8中简化Java 7的代码。</p>
<p><strong>创建<code>ActionListener</code></strong></p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Java 7</span></div><div class="line">ActionListener al = <span class="keyword">new</span> ActionListener() {</div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span>(ActionEvent e) {</div><div class="line">        System.out.println(e.getActionCommand());</div><div class="line">    }</div><div class="line">};</div><div class="line"><span class="comment">// Java 8</span></div><div class="line">ActionListener al8 = e -&gt; System.out.println(e.getActionCommand());</div></pre></td></tr></table></figure></p>
<p><strong>打印一列字符串</strong></p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Java 7</span></div><div class="line"><span class="keyword">for</span> (String s : list) {</div><div class="line">    System.out.println(s);</div><div class="line">}</div><div class="line"><span class="comment">//Java 8</span></div><div class="line">list.forEach(System.out::println);</div></pre></td></tr></table></figure></p>
<p><strong>排序一列字符串</strong></p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Java 7</span></div><div class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;String&gt;() {</div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span>(String s1, String s2) {</div><div class="line">        <span class="keyword">return</span> s1.length() - s2.length();</div><div class="line">    }</div><div class="line">});</div><div class="line"><span class="comment">//Java 8</span></div><div class="line">Collections.sort(list, (s1, s2) -&gt; s1.length() - s2.length());</div><div class="line"><span class="comment">// or</span></div><div class="line">list.sort(Comparator.comparingInt(String::length));</div></pre></td></tr></table></figure></p>
<p><strong>排序</strong></p>
<p>对排序的例子，假定已有如下的<code>Person</code>类：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{</div><div class="line"></div><div class="line">    String firstName;</div><div class="line">    String lastName;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> String <span class="title">getFirstName</span>() {</div><div class="line">        <span class="keyword">return</span> firstName;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> String <span class="title">getLastName</span>() {</div><div class="line">        <span class="keyword">return</span> lastName;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>以下展示了你如何在Java 7中按姓和名来排序：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Person&gt;() {</div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span>(Person p1, Person p2) {</div><div class="line">        <span class="keyword">int</span> n = p1.getLastName().compareTo(p2.getLastName());</div><div class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) {</div><div class="line">            <span class="keyword">return</span> p1.getFirstName().compareTo(p2.getFirstName());</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> n;</div><div class="line">    }</div><div class="line">});</div></pre></td></tr></table></figure></p>
<p>在Java 8中，代码可以减短为如下这样：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">list.sort(Comparator.comparing(Person::getLastName)</div><div class="line">        .thenComparing(Person::getFirstName));</div></pre></td></tr></table></figure></p>
<blockquote>
<p>本例使用了接口(<code>comparing</code>)的静态方法和下一章讨论的默认方法(<code>thenComparing</code>)。</p>
</blockquote>
<h2>3 默认方法</h2>
<p>为了在核心的Collection API中加入<code>stream</code>方法，Java需要另一个新特性——<em>默认方法</em>(也称作Defender方法，或虚拟扩展方法Virtual Extension methods)。这样，就可以为<code>List</code>接口增加新的方法而不破坏所有已有的实现(向后兼容性)。</p>
<p>默认方法可以加入到任何接口中，如默认方法这个名称表达的意思，任何实现了接口单没有重写方法的类会获得默认实现。</p>
<p>例如，<code>Collection</code>接口中的<code>stream</code>方法就类似如下的定义：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">default</span> <span class="keyword">public</span> Stream <span class="title">stream</span>() {</div><div class="line">	<span class="keyword">return</span> StreamSupport.stream(spliterator());</div><div class="line">}</div></pre></td></tr></table></figure></p>
<blockquote>
<p>更多分隔符(spliterator)的信息可以参考<a href="http://download.java.net/jdk8/docs/api/java/util/Collection.html#spliterator--" target="_blank" rel="external">the Java docs</a></p>
</blockquote>
<p>如果你需要其他行为的话，你可以重载默认方法。</p>
<h3>3.1 默认的和函数的(接口)</h3>
<p>接口可以有一个或多个默认方法，并且仍然是函数接口。</p>
<p>例如，来看看<code>Iterable</code>接口：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span> </span>{</div><div class="line">	Iterator iterator();</div><div class="line">	<span class="keyword">default</span> <span class="keyword">void</span> forEach(Consumer&lt; ? <span class="keyword">super</span> T&gt; action) {</div><div class="line">		Objects.requireNonNull(action);</div><div class="line">		<span class="keyword">for</span> (T t : <span class="keyword">this</span>) {</div><div class="line">			action.accept(t);</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>它包含了<code>iterator()</code>方法和<code>forEach</code>方法。</p>
<h3>3.2 多个默认方法</h3>
<p>在一些罕见的例子里，你的类实现了2个或多个接口，这些接口中可能定义了相同的默认方法，此时Java会跑出编译错误。你必须重载这些方法或选择其中一个接口的实现。例如：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">interface Foo {</div><div class="line">	<span class="keyword">default</span> <span class="keyword">void</span> talk() {</div><div class="line">		out.println(<span class="string">"Foo!"</span>);</div><div class="line">	}</div><div class="line">}</div><div class="line">interface Bar {</div><div class="line">	<span class="keyword">default</span> <span class="keyword">void</span> talk() {</div><div class="line">		out.println(<span class="string">"Bar!"</span>);</div><div class="line">	}</div><div class="line">}</div><div class="line">class FooBar implements Foo, Bar {</div><div class="line">	<span class="annotation">@Override</span></div><div class="line">	<span class="keyword">void</span> talk() { Foo.<span class="keyword">super</span>.talk(); }			</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>以上代码中，<code>talk</code>被重载了，它调用了<code>Foo</code>的<code>talk</code>方法。这与你引用一个Java 8之前的超类的语法相类似。</p>
<h3>3.3 接口中的静态方法</h3>
<p>尽管与默认方法不是强相关，可以给接口加入静态方法对Java语言来说也是一个类似的改动。</p>
<p>例如，<em>Stream</em>接口中有很多静态方法。这让&quot;帮助&quot;方法很容易就能找到，因为他们能很容易在接口中直接定位，而不是在另一个类中，如<em>StreamUtil</em>或<em>Streams</em>。</p>
<p>这是一个新的<em>Stream</em>接口的示例：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">of</span>(T... values) {</div><div class="line"> <span class="keyword">return</span> Arrays.stream(values);</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>以上方法根据给定值创建一个新的流。</p>
<h2>4 Stream(流)</h2>
<p><code>Stream</code>接口在Java 8中是如此基础的一部分，因此值得为其单独花一章来说。</p>
<h3>4.1 什么是Stream？</h3>
<p><code>Stream</code>接口在<code>java.util.stream</code>包中，它表示一列对象，有些类似Iterator接口。然而，与Iterator不同的是，它支持并行执行。</p>
<p>Stream接口支持map/filter/reduce模式，且惰性执行，这构成了Java 8函数式编程的基石(和lambda一起)。</p>
<p>出于性能考虑，也有一些派生自原始流的IntStream、DoubleStream和LongStream。</p>
<h3>4.2 生成Stream</h3>
<p>Java 8中有很多种方法来创建流，很多现有的Java核心库的类都有返回Stream的方法。</p>
<p><strong>Stream化的Collection(集合)</strong></p>
<p>最常见的创建Stream的方法是从<code>Collection</code>。</p>
<p>Colletion接口有两个默认方法来创建Stream：</p>
<ul>
<li><code>stream()</code>：返回源是Collection的一个顺序流；</li>
<li><code>parallelStream()</code>：返回源是Collection的一个可能并行的流。</li>
</ul>
<p>Stream的顺序性依赖于源头的Collection，正如Iterator一样。</p>
<p><strong>Stream化的文件</strong></p>
<p><code>BufferedReader</code>现在有了<code>lines()</code>方法可以返回Stream，例如<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a>：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> (FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"file"</span>);</div><div class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(fr)) {</div><div class="line">    br.lines().forEach(System.out::println);</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>也可以使用<code>Files.lines(Path filePath)</code>来把文件当做Stream来读取，例如：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> (Stream st = Files.lines(Paths.get(<span class="string">"file"</span>))) {</div><div class="line">    st.forEach(System.out::println);</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>注意，这会惰性求值，它不会读取整个文件，仅在你调用时读取。</p>
<blockquote>
<p>！！！<code>Files.lines(Path)</code>：任何在处理文件时(在文件打开之后)抛出的<code>IOException</code>会被包装在<code>UncheckedIOException</code>中并抛出。</p>
</blockquote>
<p><strong>Stream化文件树</strong></p>
<p><code>Files</code>类中有几个静态方法可以用Stream来浏览文件树。</p>
<ul>
<li><code>list(Path dir)</code> – 给定目录中的文件Stream。</li>
<li><code>walk(Path dir)</code><a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a> – 从给定目录开始以深度有些方式便利文件树的Stream。</li>
<li><code>walk(Path dir, int maxDepth)</code> – 和<code>walk(dir)</code>相同，但是有最大深度限制。</li>
</ul>
<p><strong>Stream化文本模式</strong></p>
<p><a href="http://download.java.net/jdk8/docs/api/java/util/regex/Pattern.html" target="_blank" rel="external">Pattern</a>类现在有了方法<code>splitAsStream(CharSequence)</code>可以创建Stream，例如：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.regex.Pattern;</div><div class="line"><span class="comment">// later on...</span></div><div class="line">Pattern patt = Pattern.compile(<span class="string">","</span>);</div><div class="line">patt.splitAsStream(<span class="string">"a,b,c"</span>)</div><div class="line">    .forEach(System.out::println);</div></pre></td></tr></table></figure></p>
<p>以上代码使用了一个简易的模式，逗号','，将文本拆分成Stream并打印。这会产生以下输出：</p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a</div><div class="line">b</div><div class="line"><span class="built_in">c</span></div></pre></td></tr></table></figure></p>
<p><strong>无限Stream</strong></p>
<p>使用Stream的<code>generate</code>和<code>iterate</code>静态方法，你可以创建Stream包含无穷的对象。例如，可以调用<code>generate</code>来创建提供无穷对象的Stream，如下所示：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Stream.generate(() -&gt; <span class="keyword">new</span> Dragon());</div></pre></td></tr></table></figure></p>
<p>例如，你可以使用这样的技术来产生CPU负载或内存使用信息的Stream。但是，你必须小心使用，它和无穷循环很类似。</p>
<p>你也可以使用<code>generate</code>来创建无穷随机数源的Stream，例如：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Stream.generate(() -&gt; Math.random());</div></pre></td></tr></table></figure></p>
<p>然而，<code>java.util.Random</code>类已经在新方法中提供了这些功能：<code>ints()</code>、<code>longs()</code>和<code>doubles()</code>。这些方法的每一个都类似如下定义：</p>
<ul>
<li><code>ints()</code>：随机整数的无穷Stream。</li>
<li><code>ints(int n, int m)</code>：n(含)和m(不含)之间的随机整数的无穷Stream。</li>
<li><code>ints(long size)</code>：给定长度的随机整数Stream。</li>
<li><code>ints(long size, int n, int m)</code>：给定长度，给定范围的随机整数Stream。</li>
</ul>
<p><code>iterate</code>方法和<code>generate</code>方法类似，但是它提供了初始值，和改变值的<code>Function</code>。例如，你可以用以下代码来便利整数：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Stream.iterate(<span class="number">1</span>, i -&gt; i+<span class="number">1</span>)</div><div class="line">    .forEach(System.out::print);</div></pre></td></tr></table></figure></p>
<p>这会持续打印出&quot;1234......&quot;直到你停止程序。</p>
<blockquote>
<p>我们之后会讨论一些停止无穷Stream的方法(<code>filter</code>和<code>limit</code>)。</p>
</blockquote>
<p><strong>Range</strong></p>
<p>还有一些方法是用于创建一段有限的整数Stream。</p>
<p>例如，<code>IntStream</code>接口的静态方法<code>range</code>：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">IntStream.range(<span class="number">1</span>, <span class="number">11</span>)</div><div class="line">    .forEach(System.out::println);</div></pre></td></tr></table></figure></p>
<p>以上代码会打印数字1到10。</p>
<p>每个基本Stream(IntStream、DoubleStream和LongStream)都有一个相应的<code>range</code>方法。</p>
<p><strong>Stream化任何对象</strong></p>
<p>使用以下两个方法，就可以从任意个元素或者数组创建Stream：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Stream&lt;Integer&gt; s = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</div><div class="line">Stream&lt;Object&gt; s2 = Arrays.stream(array);</div></pre></td></tr></table></figure></p>
<p><code>Stream.of</code>可以输入任意类型的任意个参数。</p>
<h3>4.3 For Each</h3>
<p>对Stream可以进行最基础操作就是循环，可以使用<code>forEach</code>方法来完成。</p>
<p>例如，打印当前目录下的所有文件，可以如下操作：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Files.list(Paths.get(<span class="string">"."</span>))</div><div class="line">    .forEach(System.out::println);</div></pre></td></tr></table></figure></p>
<p>对大多数情况而言，可以替代&quot;for循环&quot;，而且更加简洁，并且更加面向对象，因为代理了实际循环的实现。</p>
<h3>4.4 Map/Filter/Reduce</h3>
<p>lambda表达式和默认方法让我们在Java 8中可以实现map/filter/reduce，实际上，标准库中已经实现了这些。</p>
<p>例如，设想你从一列运动员姓名中获取他们的当前分数，并找出其中最高的分数。一个简单的<code>PlayerPoints</code>类和<code>getPoints</code>方法可以如下定义：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayerPoints</span> </span>{</div><div class="line"> <span class="keyword">public</span> <span class="keyword">final</span> String name;</div><div class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> points;</div><div class="line"> </div><div class="line"> <span class="keyword">public</span> <span class="title">PlayerPoints</span>(String name, <span class="keyword">long</span> points) {</div><div class="line">   <span class="keyword">this</span>.name = name;</div><div class="line">   <span class="keyword">this</span>.points = points;</div><div class="line"> } </div><div class="line"> </div><div class="line"> <span class="keyword">public</span> String <span class="title">toString</span>() {</div><div class="line">   <span class="keyword">return</span> name + <span class="string">":"</span> + points;</div><div class="line"> }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getPoints</span>(<span class="keyword">final</span> String name) {</div><div class="line">	<span class="comment">// gets the Points for the Player</span></div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>找出最高分运动员可以使用Java 8非常简单的实现，如下：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">PlayerPoints highestPlayer = </div><div class="line">  names.stream().map(name -&gt; <span class="keyword">new</span> PlayerPoints(name, getPoints(name)))</div><div class="line">	.reduce(<span class="keyword">new</span> PlayerPoints(<span class="string">""</span>, <span class="number">0.0</span>), </div><div class="line">			(s1, s2) -&gt; (s1.points &gt; s2.points) ? s1 : s2);</div></pre></td></tr></table></figure></p>
<p>在Java 7中也可以使用<code>dollar</code>库(或其他类似Guava和Functional-Java的库)来实现，但是可能会非常的冗长，如下所示：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">PlayerPoints highestPlayer = </div><div class="line">  $(names).map(<span class="keyword">new</span> Function&lt;String, PlayerPoints&gt;() { </div><div class="line">		<span class="keyword">public</span> PlayerPoints <span class="title">call</span>(String name) { </div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> PlayerPoints(name, getPoints(name));</div><div class="line">		}</div><div class="line">	})</div><div class="line">	.reduce(<span class="keyword">new</span> PlayerPoints(<span class="string">""</span>, <span class="number">0.0</span>), </div><div class="line">	<span class="keyword">new</span> BiFunction&lt;PlayerPoints, PlayerPoints, PlayerPoints&gt;() {</div><div class="line">		<span class="keyword">public</span> PlayerPoints <span class="title">call</span>(PlayerPoints s1, PlayerPoints s2) { </div><div class="line">			<span class="keyword">return</span> (s1.points &gt; s2.points) ? s1 : s2;</div><div class="line">		}</div><div class="line">	});</div></pre></td></tr></table></figure></p>
<p>用这种方法编程的最大益处(除了代码行数减少)是可以隐藏map/reduce的内在实现的能力。例如，map和reduce可能是并发实现的，允许你容易的发挥多处理器的优势。我们将在下面的章节介绍一种这么做的方法(ParallelArray)。</p>
<h3>4.5 Parallel Array(并行数组)</h3>
<p><code>ParallelArray</code>是JSR-166的一部分，但最终<a href="http://puredanger.com/tech/2009/11/15/jsr-166-concurrency-updates-hit-jdk-7/" target="_blank" rel="external">被排除在标准的Java库</a>。它确实存在，并被发布到公共领域(可以通过JSR网站下载)。</p>
<p>虽然它早就在那，但是实在不易使用，直到闭包出现在Java语言中才改变了这一点。在Java 7中可以如下使用ParallelArray：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// with this class</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>{</div><div class="line">    String name;</div><div class="line">    <span class="keyword">int</span> graduationYear;</div><div class="line">    <span class="keyword">double</span> gpa;</div><div class="line">}</div><div class="line"><span class="comment">// this predicate</span></div><div class="line"><span class="keyword">final</span> Ops.Predicate&lt;Student&gt; isSenior = </div><div class="line">	<span class="keyword">new</span> Ops.Predicate&lt;&gt;() {</div><div class="line">		<span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">op</span>(Student s) {</div><div class="line">			<span class="keyword">return</span> s.graduationYear == Student.THIS_YEAR;</div><div class="line">		}</div><div class="line">	};</div><div class="line"><span class="comment">// and this conversion operation</span></div><div class="line"><span class="keyword">final</span> Ops.ObjectToDouble&lt;Student&gt; selectGpa = </div><div class="line">	<span class="keyword">new</span> Ops.ObjectToDouble&lt;&gt;() {</div><div class="line">		<span class="keyword">public</span> <span class="keyword">double</span> <span class="title">op</span>(Student student) {</div><div class="line">			<span class="keyword">return</span> student.gpa;</div><div class="line">		}</div><div class="line">	};</div><div class="line"><span class="comment">// create a fork-join-pool</span></div><div class="line">ForkJoinPool fjPool = <span class="keyword">new</span> ForkJoinPool();</div><div class="line">ParallelArray&lt;Student&gt; students = <span class="keyword">new</span> ParallelArray&lt;&gt;(fjPool, data);</div><div class="line"><span class="comment">// find the best GPA:</span></div><div class="line"><span class="keyword">double</span> bestGpa = students.withFilter(isSenior)</div><div class="line">                         .withMapping(selectGpa)</div><div class="line">                         .max();</div></pre></td></tr></table></figure></p>
<p>在Java 8中，可以这么做：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// create a fork-join-pool</span></div><div class="line">ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</div><div class="line">ParallelArray&lt;Student&gt; students = <span class="keyword">new</span> ParallelArray&lt;&gt;(pool,data);</div><div class="line"><span class="comment">// find the best GPA:</span></div><div class="line"><span class="keyword">double</span> bestGpa = students</div><div class="line">    .withFilter((Student s) -&gt; (s.graduationYear == THIS_YEAR))</div><div class="line">    .withMapping((Student s) -&gt; s.gpa)</div><div class="line">    .max();</div></pre></td></tr></table></figure></p>
<p>然而，Java 8提供了<code>stream()</code>和<code>parallelStream()</code>使这项工作更加容易：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> bestGpa = students</div><div class="line">    .parallelStream()</div><div class="line">    .filter(s -&gt; (s.graduationYear == THIS_YEAR))</div><div class="line">    .mapToDouble(s -&gt; s.gpa)</div><div class="line">    .max().getAsDouble();</div></pre></td></tr></table></figure></p>
<p>这使从顺序执行的实现转为并行实现变得格外简单。</p>
<blockquote>
<p><strong>Groovy GPars</strong></p>
<p>如果使用Groovy和GPars库，现在可以类似的使用，如下所示：</p>
</blockquote>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">GParsPool.withPool {</div><div class="line">   <span class="comment">// a map-reduce functional style (students is a Collection)</span></div><div class="line">   def bestGpa = students.parallel</div><div class="line">       .filter{ s -&gt; s.graduationYear == Student.THIS_YEAR }</div><div class="line">       .map{ s -&gt; s.gpa }</div><div class="line">       .max()</div><div class="line">}</div></pre></td></tr></table></figure></p>
<blockquote>
<p>静态方法<code>GParsPool.withPool</code>输入一个闭包并使用多个方法增强任意Collection(使用Groovy的类别方法)。<code>parallel</code>方法实际上从给定的Collection创建了<code>ParallelArray</code>，并通过一个薄包装来使用它。</p>
</blockquote>
<h3>4.6 Peek(偷看)</h3>
<p>你可以&quot;偷看&quot;Stream来做一些操作但却不中断Stream。</p>
<p>例如，可以打印元素来调试代码：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Files.list(Paths.get(<span class="string">"."</span>))</div><div class="line">    .map(Path::getFileName)</div><div class="line">    .peek(System.out::println)</div><div class="line">    .forEach(p -&gt; doSomething(p));</div></pre></td></tr></table></figure></p>
<p>可以使用任何想要的操作，但是<em>不能</em>修改元素，如果想修改的话，可以使用<code>map</code>来替代。</p>
<h3>4.7 Limit(限制)</h3>
<p><code>limit(int n)</code>方法可以用来限制Stream中元素为给定个数，例如：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Random rnd = <span class="keyword">new</span> Random();</div><div class="line">rnd.ints().limit(<span class="number">10</span>)</div><div class="line">    .forEach(System.out::println);</div></pre></td></tr></table></figure></p>
<p>以上代码打印10个随机整数。</p>
<h3>4.8 Sort(排序)</h3>
<p>Stream也有<code>sort()</code>方法来给流排序。像所有Stream的<em>中间方法</em>(例如map、filter和peek)，<code>sort()</code>方法是惰性执行的，在中止操作调用(如reduce和forEach)之前，什么也不做。但是，你必须在对无限流调用<code>sort()</code>之前调用限制操作如<code>limit</code>。</p>
<p>例如，以下代码会抛出运行时异常(使用构建版本1.8.0-b132)：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rnd.ints().sorted().limit(<span class="number">10</span>)</div><div class="line">    .forEach(System.out::println);</div></pre></td></tr></table></figure></p>
<p>然而，以下代码就工作正常：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rnd.ints().limit(<span class="number">10</span>).sorted()</div><div class="line">    .forEach(System.out::println);</div></pre></td></tr></table></figure></p>
<p>也可以在调用<code>filter()</code>之后调用<code>sorted()</code>。例如，以下代码打印当前目录下的前5个Java文件的文件名：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Files.list(Paths.get(<span class="string">"."</span>))</div><div class="line">    .map(Path::getFileName) <span class="comment">// still a path</span></div><div class="line">    .map(Path::toString) <span class="comment">// convert to Strings</span></div><div class="line">    .filter(name -&gt; name.endsWith(<span class="string">".java"</span>))</div><div class="line">    .sorted() <span class="comment">// sort them alphabetically</span></div><div class="line">    .limit(<span class="number">5</span>) <span class="comment">// first 5</span></div><div class="line">    .forEach(System.out::println);</div></pre></td></tr></table></figure></p>
<p>以上代码做了这些事情：</p>
<ul>
<li>列出当前目录下的所有文件。</li>
<li>将这些文件映射到文件名(译者注：即获取文件名)。</li>
<li>获取那些以&quot;.java&quot;结尾的文件名。</li>
<li>只取前5个文件名(按字母排序)。</li>
<li>打印这些文件名。</li>
</ul>
<h3>4.9 Collector(收集器)和统计量</h3>
<p>正因Stream是惰性求值，并支持并行执行，因此需要特别的方法来汇总结果，这就是Collector(收集器)。</p>
<p>Collector表示汇总Stream的元素成一个结果的方法，它包含3个部分：</p>
<ul>
<li>初始值。</li>
<li>将值加到初始值上的累加器。</li>
<li>将两个结果合并成一个的归并器。</li>
</ul>
<p>有两个方法来完成：<code>collect(supplier,accumulator,combiner)</code>和<code>collect(Collector)</code>(省略类型)。</p>
<p>可喜的是，Java 8提供的多个内建的Collector。可以通过如下方法Import这些类：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.*;</div></pre></td></tr></table></figure></p>
<p><strong>简单的Collector</strong></p>
<p>最简单的collector是像<code>toList()</code>和<code>toCollection()</code>那样的：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Accumulate names into a List</span></div><div class="line">List&lt;String&gt; list = dragons.stream()</div><div class="line">        .map(Dragon::getName)</div><div class="line">        .collect(toList());</div><div class="line"></div><div class="line"><span class="comment">// Accumulate names into a TreeSet</span></div><div class="line">Set&lt;String&gt; set = dragons.stream()</div><div class="line">        .map(Dragon::getName)</div><div class="line">        .collect(toCollection(TreeSet::<span class="keyword">new</span>));</div></pre></td></tr></table></figure></p>
<p><strong>Join(合并)</strong></p>
<p>如果你熟悉Apache Common的<code>StringUtil.join</code>，<code>joining</code>collector与其很相似。它可以使用给定的分隔符合并Stream，如下：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String names = dragons.stream()</div><div class="line">        .map(Dragon::getName)</div><div class="line">        .collect(joining(<span class="string">","</span>));</div></pre></td></tr></table></figure></p>
<p>以上代码合并所有的名字为一个字符串，并使用逗号分割。</p>
<p><strong>统计量</strong></p>
<p>更加复杂的collector合并成单一值，例如，可以使用&quot;averaging&quot;Collector来获取平均值，如下：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">System.out.println(<span class="string">"\n-----&gt;Average line length:"</span>);</div><div class="line">System.out.println(</div><div class="line">    Files.lines(Paths.get(<span class="string">"Nio.java"</span>))</div><div class="line">        .map(String::trim)</div><div class="line">        .filter(s -&gt; !s.isEmpty())</div><div class="line">        .collect(averagingInt(String::length))</div><div class="line">        );</div></pre></td></tr></table></figure></p>
<p>以上代码计算文件&quot;Nio.java&quot;中的所有非空行长度的平均值。</p>
<p>有些情况下需要获取集合的多个统计量，但是因为Stream会因为调用<code>collect</code>而被消费，所以，必须一次性计算所有的统计量。这正是<strong>SummaryStatistics</strong>的功能，如果要使用的话，需要先import：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.IntSummaryStatistics;</div></pre></td></tr></table></figure></p>
<p>然后就可以使用<code>summarizingInt</code>collector，如下：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">IntSummaryStatistics stats = Files.lines(Paths.get(<span class="string">"Nio.java"</span>))</div><div class="line">        .map(String::trim)</div><div class="line">        .filter(s -&gt; !s.isEmpty())</div><div class="line">        .collect(summarizingInt(String::length));</div><div class="line"></div><div class="line">System.out.println(stats.getAverage());</div><div class="line">System.out.println(<span class="string">"count="</span> + stats.getCount());</div><div class="line">System.out.println(<span class="string">"max="</span> + stats.getMax());</div><div class="line">System.out.println(<span class="string">"min="</span> + stats.getMin());</div></pre></td></tr></table></figure></p>
<p>以上代码得到了和之前一样的平均值，并且同时也计算出了最大值、最小值和元素个数。</p>
<blockquote>
<p>也提供了<code>summarizingLong</code>和<code>summarizingDouble</code>。</p>
</blockquote>
<p>另一个等价的方法是，把Stream map到基础类型，然后调用<code>summaryStatistics()</code>，如下：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">IntSummaryStatistics stats = Files.lines(Paths.get(<span class="string">"Nio.java"</span>))</div><div class="line">    .map(String::trim)</div><div class="line">    .filter(s -&gt; !s.isEmpty())</div><div class="line">    .mapToInt(String::length)</div><div class="line">    .summaryStatistics();</div></pre></td></tr></table></figure></p>
<h3>4.10 分组和分块</h3>
<p><code>groupingBy</code> collector根据提供的方法把元素分组，例如：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Group by first letter of name</span></div><div class="line">List&lt;Dragon&gt; dragons = getDragons();</div><div class="line">Map&lt;Character,List&lt;Dragon&gt;&gt; map = dragons.stream()</div><div class="line">        .collect(groupingBy(dragon -&gt; dragon.getName().charAt(<span class="number">0</span>)));</div></pre></td></tr></table></figure></p>
<p>类似的，<code>partitioningBy</code>方法创建一个布尔类型为键的映射，例如：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Group by whether or not the dragon is green</span></div><div class="line">Map&lt;Boolean,List&lt;Dragon&gt;&gt; map = dragons.stream()</div><div class="line">        .collect(partitioningBy(Dragon::isGreen));</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>并行分组</strong></p>
<p>为了并行的执行分组(如果不关心顺序的话)，可以使用<code>groupingByConcurrent</code>方法。被操作的Stream应该是无序的，这样分组才能并行执行，例如：</p>
<p><code>dragons.parallelStream().unordered().collect(groupingByConcurrent(Dragon::getColor));.</code></p>
</blockquote>
<h3>4.11 与Java 7的比较</h3>
<p>为了更好的展示Java 8的Stream的优势，以下是一些Java 7里的示例代码和新版代码的比较：</p>
<p><strong>求最大值</strong></p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Java 7</span></div><div class="line"><span class="keyword">double</span> max = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (Double d : list) {</div><div class="line">    <span class="keyword">if</span> (d &gt; max) {</div><div class="line">        max = d;</div><div class="line">    }</div><div class="line">}</div><div class="line"><span class="comment">//Java 8</span></div><div class="line">max = list.stream().reduce(<span class="number">0.0</span>, Math::max);</div><div class="line"><span class="comment">// or</span></div><div class="line">max = list.stream().mapToDouble(Number::doubleValue).max().getAsDouble();</div></pre></td></tr></table></figure></p>
<p><strong>计算平均值</strong></p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> total = <span class="number">0</span>;</div><div class="line"><span class="keyword">double</span> ave = <span class="number">0</span>;</div><div class="line"><span class="comment">// Java 7</span></div><div class="line"><span class="keyword">for</span> (Double d : list) {</div><div class="line">    total += d;</div><div class="line">}</div><div class="line">ave = total / ((<span class="keyword">double</span>) list.size());</div><div class="line"><span class="comment">//Java 8</span></div><div class="line">ave = list.stream().mapToDouble(Number::doubleValue).average().getAsDouble();</div></pre></td></tr></table></figure></p>
<p><strong>打印数字1到10</strong></p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Java 7</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) {</div><div class="line">    System.out.println(i);</div><div class="line">}</div><div class="line"><span class="comment">// Java 8</span></div><div class="line">IntStream.range(<span class="number">1</span>, <span class="number">11</span>)</div><div class="line">    .forEach(System.out::println);</div><div class="line"><span class="comment">//or</span></div><div class="line">Stream.iterate(<span class="number">1</span>, i -&gt; i+<span class="number">1</span>).limit(<span class="number">10</span>)</div><div class="line">    .forEach(System.out::println);</div></pre></td></tr></table></figure></p>
<p><strong>合并多个字符串</strong></p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Java 7 using commons-util</span></div><div class="line">List&lt;String&gt; names = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line"><span class="keyword">for</span> (Dragon dragon : dragons) </div><div class="line">    names.add(dragon.getName());</div><div class="line">String names = StringUtils.join(names, <span class="string">","</span>);</div><div class="line"><span class="comment">// Java 8</span></div><div class="line">String names = dragons.stream()</div><div class="line">    .map(Dragon::getName)</div><div class="line">    .collect(Collectors.joining(<span class="string">","</span>));</div></pre></td></tr></table></figure></p>
<h2>5 Optional类</h2>
<p>Java 8在<code>java.util</code>包中提供了<code>Optional</code>类来防止返回null值(会导致<code>NullPointerException</code>)。它和Google Guava的<a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/base/Optional.html" target="_blank" rel="external">Optional</a>很相似，也类似Nat Pryce的<a href="http://www.natpryce.com/articles/000776.html" target="_blank" rel="external">Maybe</a>类和Scala的Option类。</p>
<blockquote>
<p><strong>百万美元错误</strong></p>
<p>Tony Hoare，null的发明者，已经因为它的<a href="http://qconlondon.com/london-2009/presentation/Null+References:+The+Billion+Dollar+Mistake" target="_blank" rel="external">&quot;百万美元错误&quot;</a>而被记录在案。除了你对nul的看法，已经有人在编译期null检查部分和自动代码检查过程中做出了很大努力，例如，JSR-305中的<code>@Nonnull</code>注解。<code>Optional</code>让API设计者可以更简单的来避免null。</p>
</blockquote>
<p>可以用<code>Optional.of(x)</code>来包装一个非null值，<code>Optional.empty()</code>来表示值缺失，<code>Optional.ofNullable(x)</code>来从可能为空的引用创建<code>Optional</code>。</p>
<p>在创建Optional的实例之后，然后使用<code>isPresent()</code>确认是否有值，并用<code>get()</code>来获取值。Optional提供了一些其他有用的方法来处理值缺失：</p>
<ul>
<li><code>orElse(T)</code> – 如果Optional是空，则返回给定的值。</li>
<li><code>orElseGet(Supplier&lt;T&gt;)</code> – 如果Optional是空，则调用给定的提供者来产生一个值。</li>
<li><code>orElseThrow(Supplier&lt;X extends Throwable&gt;)</code> – 如果Optional是空，则调用给定的提供者来抛出一个异常。</li>
</ul>
<p>也提供了一些函数式(对lambda友好)的方法，如下：</p>
<ul>
<li><code>filter(Predicate&lt;? super T&gt; predicate)</code> – 过滤值并返回新的Optional。</li>
<li><code>flatMap(Function&lt;? super T,Optional&lt;U&gt;&gt; mapper)</code> – 进行Map操作并返回Optional。</li>
<li><code>ifPresent(Consumer&lt;? super T&gt; consumer)</code> – 仅当有值(无返回值)的时候，执行给定的消费者</li>
<li><code>map(Function&lt;? super T,? extends U&gt; mapper)</code> – 用给定的Map方法并返回新的Optional。</li>
</ul>
<blockquote>
<p><strong>Stream Optional(流的Optional)</strong></p>
<p>新的<code>Stream</code>接口有一些返回Optional的方法(当Stream中没有值的时候)：</p>
<ul>
<li><code>reduce(BinaryOperator&lt;T&gt; accumulator)</code> – 把Stream reduce成单个值。、</li>
<li><code>max(Comparator&lt;? super T&gt; comparator)</code> – 返回最大值。</li>
<li><code>min(Comparator&lt;? super T&gt; comparator)</code> – 返回最小值。</li>
</ul>
</blockquote>
<h2>6 Nashorn</h2>
<p><em>Nashorn</em>替换了<code>Rhino</code>成为了Oracle JVM中默认的JavaScript引擎。由于使用的JVM的<code>invokedynamic</code>特性，Nashorn更加快，它也包含了命令行工具(<code>jjs</code>)。</p>
<h3>6.1 <code>jjs</code></h3>
<p>JDK 8包含了命令行工具<code>jjs</code>来运行JavaScript。</p>
<p>你可以通过命令行运行JavaScript文件(假定你已经把Java 8的bin目录放在了<code>$PATH</code>里面)：</p>
<p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ jjs script.js</div></pre></td></tr></table></figure></p>
<p>这对运行脚本很有用，例如，假如你想很快求出几个数的和，如下：</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> data = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>]</div><div class="line"><span class="keyword">var</span> sum = data.reduce(<span class="function"><span class="keyword">function</span><span class="params">(x, y)</span> </span>{<span class="keyword">return</span> x + y}, <span class="number">0</span>)</div><div class="line">print(sum)</div></pre></td></tr></table></figure></p>
<p>运行上述代码会打印<code>27</code>。</p>
<h3>6.2 脚本</h3>
<p>使用<code>-scripting</code>参数运行jjs进入交互的shell，然后就可以键入并执行JavaScript。</p>
<p>可以在字符串中嵌入变量并对它们求值，例如：</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">jjs&gt; <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>()</div><div class="line">jjs&gt; print(<span class="string">"${date}"</span>)</div></pre></td></tr></table></figure></p>
<p>以上代码会打印出当前的日期和时间。</p>
<h3>6.3 脚本引擎</h3>
<p>也可以在Java中动态的运行JavaScript。</p>
<p>首先，需要import脚本引擎：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> javax.script.ScriptEngine;</div><div class="line"><span class="keyword">import</span> javax.script.ScriptEngineManager;</div></pre></td></tr></table></figure></p>
<p>然后，调用<code>ScriptEngineManager</code>来获取Nashorn引擎：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ScriptEngineManager engineManager = <span class="keyword">new</span> ScriptEngineManager();</div><div class="line">ScriptEngine engine = engineManager.getEngineByName(<span class="string">"nashorn"</span>);</div></pre></td></tr></table></figure></p>
<p>现在就可以任意时候对JavaScript代码求值了：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">engine.eval(<span class="string">"function p(s) { print(s) }"</span>);</div><div class="line">engine.eval(<span class="string">"p('Hello Nashorn');"</span>);</div></pre></td></tr></table></figure></p>
<p><code>eval</code>方法也可以用<code>Filereader</code>类型做输入参数：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">engine.eval(<span class="keyword">new</span> FileReader(<span class="string">'library.js'</span>));</div></pre></td></tr></table></figure></p>
<p>这样就可以引入并运行任何JavaScript代码。然而，需要知道的是，浏览器中提供的典型变量（窗口，文档等）将不可用。</p>
<h3>6.4 引入</h3>
<p>在JavaScript中，可以通过<em>JavaImporter</em>引入并使用Java类和包。</p>
<p>例如，引入<code>java.util</code>、IO和NIO的包：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var imports = <span class="keyword">new</span> JavaImporter(java.util, java.io, java.nio.file);</div><div class="line">with (imports) {</div><div class="line">        var paths = <span class="keyword">new</span> LinkedList();</div><div class="line">        print(paths <span class="keyword">instanceof</span> LinkedList); <span class="comment">//true</span></div><div class="line">        paths.add(Paths.get(<span class="string">"file1"</span>));</div><div class="line">        paths.add(Paths.get(<span class="string">"file2"</span>));</div><div class="line">        paths.add(Paths.get(<span class="string">"file3"</span>));</div><div class="line">        print(paths) <span class="comment">// [file1, file2, file3]</span></div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>以上展示了<code>paths</code>是<code>LinkedList</code>的实例，并打印list。</p>
<p>之后，就可以添加如下代码来把文本写入文件：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (var i=<span class="number">0</span>; i &lt; paths.size(); i++)</div><div class="line">	Files.newOutputStream(paths.get(i))</div><div class="line">		.write(<span class="string">"test\n"</span>.getBytes());</div></pre></td></tr></table></figure></p>
<p>我们可以使用已有的Java类，也可以创建新的类。</p>
<h3>6.5 扩展</h3>
<p>可以使用<code>Java.type</code>和<code>Java.extend</code>方法来扩展Java类和接口。例如，可以扩展Callable接口并实现<code>call</code>方法：</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> concurrent = <span class="keyword">new</span> JavaImporter(java.util, java.util.concurrent);</div><div class="line"><span class="keyword">var</span> Callable = Java.type(<span class="string">"java.util.concurrent.Callable"</span>);</div><div class="line"><span class="keyword">with</span> (concurrent) {</div><div class="line">  <span class="keyword">var</span> executor = Executors.newCachedThreadPool();</div><div class="line">  <span class="keyword">var</span> tasks = <span class="keyword">new</span> LinkedHashSet();</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">200</span>; i++) {</div><div class="line">    <span class="keyword">var</span> MyTask = Java.extend(Callable, {call: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{print(<span class="string">"task "</span> + i)}})</div><div class="line">    <span class="keyword">var</span> task = <span class="keyword">new</span> MyTask();</div><div class="line">    tasks.add(task);</div><div class="line">    executor.submit(task);</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure></p>
<h3>6.6 Invocable</h3>
<p>也可以直接从Java中调用JavaScript方法。</p>
<p>首先，需要将引擎的类型转换为Invocable接口：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Invocable inv = (Invocable) engine;</div></pre></td></tr></table></figure></p>
<p>然后，调用任何方法只要简单的使用<code>invokeFunction</code>方法，例如：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">engine.eval(<span class="string">"function p(s) { print(s) }"</span>);</div><div class="line">inv.invokeFunction(<span class="string">"p"</span>, <span class="string">"hello"</span>);</div></pre></td></tr></table></figure></p>
<p>最后，就可以调用<code>getInterface</code>方法用JavaScript来实现任意接口。</p>
<p>例如，已有如下的<code>JPrinter</code>接口，可以如下调用：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">JPrinter</span> </span>{</div><div class="line">    <span class="keyword">void</span> p(String s);</div><div class="line">}</div><div class="line"><span class="comment">// later on...</span></div><div class="line">JPrinter printer = inv.getInterface(JPrinter.class);</div><div class="line">printer.p(<span class="string">"Hello again!"</span>);</div></pre></td></tr></table></figure></p>
<h2>7 新的Date和Time API</h2>
<p>Java 8引入了新的Date/Time API，这些API线程安全、易用、比之前的API更加全面。Java的Calendar实现没有很多变化，这是因为它是首次引入，且<a href="http://www.joda.org/joda-time/" target="_blank" rel="external">Joda-Time</a>广泛的被认为是一个很好的替代。Java 8的新Date/Time API与Joda-Time非常相似。</p>
<h3>7.1 新的类</h3>
<p>引人注意的最注意差别是有多个不同的类来表示时间、日期、时间段、和特定时区的数据，也有一些不同日期类和时间类之间的转换器。</p>
<p>对不含时区信息的日期和时间，使用如下类：</p>
<ul>
<li><code>LocalDate</code> – 日、月、年。</li>
<li><code>LocalTime</code> – 仅含时间。</li>
<li><code>LocalDateTime</code> – 含日期和时间。</li>
</ul>
<p>对特定时区的时间，可以用<code>ZonedDateTime</code>。</p>
<p>在Java 8之前，为了计算之后8消失的时间，需要像下面这样写：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Calendar cal = Calendar.getInstance();</div><div class="line">cal.add(Calendar.HOUR, <span class="number">8</span>);</div><div class="line">cal.getTime(); <span class="comment">// actually returns a Date</span></div></pre></td></tr></table></figure></p>
<p>在Java 8中，可以更简单的这样写：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LocalTime now = LocalTime.now();</div><div class="line">LocalTime later = now.plus(<span class="number">8</span>, HOURS);</div></pre></td></tr></table></figure></p>
<p>也有命名清晰的方法，如<code>plusDays</code>、<code>plusMonths</code>、<code>minusDays</code>、<code>minusMonths</code>。如下：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">LocalDate today = LocalDate.now();</div><div class="line">LocalDate thirtyDaysFromNow = today.plusDays(<span class="number">30</span>);</div><div class="line">LocalDate nextMonth = today.plusMonths(<span class="number">1</span>);</div><div class="line">LocalDate aMonthAgo = today.minusMonths(<span class="number">1</span>);</div></pre></td></tr></table></figure></p>
<p>注意，每个方法都返回不同的<code>LocalDate</code>实例，原本的LocalDate对象<code>today</code>并未变化。这是因为新的Date-Time类型是不可变的，是它们变得线程安全和可缓存的。</p>
<h3>7.2 创建</h3>
<p>创建性的日期和时间对象在Java 8中更加容易也更加不易犯错。每个类型都是不可变的，且有静态工厂方法。</p>
<p>例如，创建新的LocalDate在2014-03-15这天，可以如下简单的创建：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LocalDate date = LocalDate.of(<span class="number">2014</span>, <span class="number">3</span>, <span class="number">15</span>);</div></pre></td></tr></table></figure></p>
<p>考虑跟多类型安全的话，可以使用新的枚举类型<code>Month</code>：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">date = LocalDate.of(<span class="number">2014</span>, Month.MARCH, <span class="number">15</span>);</div></pre></td></tr></table></figure></p>
<p>也可以通过结合LocalDate和LocalTime的实例来简单的创建LocalDateTime对象：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LocalTime time = LocalTime.of(<span class="number">12</span>, <span class="number">15</span>, <span class="number">0</span>);</div><div class="line">LocalDateTime datetime = date.atTime(time);</div></pre></td></tr></table></figure></p>
<p>也能调用(LocalDate的)以下方法：</p>
<ul>
<li><code>atTime(int hour, int minute)</code></li>
<li><code>atTime(int hour, int minute, int second)</code></li>
<li><code>atTime(int hour, int minute, int second, int nanoOfSecond)</code></li>
</ul>
<p>每个类都有<code>now()</code>方法，相应的返回调用时瞬间的时间(或日期)。</p>
<h3>7.3 枚举类型</h3>
<p>Java 8增加了一些枚举类型，如<code>java.time.temporal.ChronoUnit</code>用来表示类似&quot;天&quot;或&quot;小时&quot;的概念替换掉Calendar API中的整数常量，例如：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">LocalDate today = LocalDate.now();</div><div class="line">LocalDate nextWeek = today.plus(<span class="number">1</span>, ChronoUnit.WEEKS);</div><div class="line">LocalDate nextMonth = today.plus(<span class="number">1</span>, ChronoUnit.MONTHS);</div><div class="line">LocalDate nextYear = today.plus(<span class="number">1</span>, ChronoUnit.YEARS);</div><div class="line">LocalDate nextDecade = today.plus(<span class="number">1</span>, ChronoUnit.DECADES);</div></pre></td></tr></table></figure></p>
<p>也有<code>java.time.DayOfWeek</code>、<code>java.time.Month</code>枚举类型。</p>
<p><code>Month</code>枚举类型可以用来创建LocalDates，也可以由<code>LocalDate::getMonth</code>返回。如，以下是创建LocalDate并打印月份的例子：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// import java.time.Month;</span></div><div class="line">LocalDate date = LocalDate.of(<span class="number">2014</span>, Month.MARCH, <span class="number">27</span>);</div><div class="line">System.out.println(date.getMonth());</div></pre></td></tr></table></figure></p>
<p>以上代码会打印出&quot;MARCH&quot;。</p>
<h3>7.4 Clock(时钟)</h3>
<p><code>Clock</code>类可以用于连接日期和时间以构建测试。在生成环境可以用普通时钟，在测试环境可以用另一个时钟。</p>
<p>获取默认的时钟，可以用以下代码：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Clock.systemDefaultZone();</div></pre></td></tr></table></figure></p>
<p>然后clock就可以传入进工厂方法，如下：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LocalTime time = LocalTime.now(clock);</div></pre></td></tr></table></figure></p>
<h3>7.5 时间区间和时间长度</h3>
<p>模拟人的理解，Java 8有两个类型来表示时间差，时间区间和时间长度(Period and Duration)。</p>
<p>时间长度是基于时间的时间量，例如&quot;34.5秒&quot;；时间区间是基于日期的时间量，例如&quot;2年3个月4天&quot;。</p>
<p>时间区间和时间长度可以通过<code>between</code>方法来确定：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Period p = Period.between(date1, date2);</div><div class="line">Duration d = Duration.between(time1, time2);</div></pre></td></tr></table></figure></p>
<p>也可以通过静态方法来创建，例如，时间长度可以通过任意值的天、小时、分、秒来创建：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Duration twoHours = Duration.ofHours(<span class="number">2</span>);</div><div class="line">Duration tenMinutes = Duration.ofMinutes(<span class="number">10</span>);</div><div class="line">Duration thirtySecs = Duration.ofSeconds(<span class="number">30</span>);</div></pre></td></tr></table></figure></p>
<p>Java 8的LocalTime类型可以加减时间区间和时间长度，例如：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LocalTime t2 = time.plus(twoHours);</div></pre></td></tr></table></figure></p>
<h3>7.6 时间调整(<code>TemporalAdjusters</code>)</h3>
<p><code>TemporalAdjusters</code>可以用来做很麻烦的日期&quot;数学计算&quot;，这在业务功能中很常用。例如，可以用来获取&quot;某月的第一天&quot;和&quot;下个周二&quot;。</p>
<p><code>java.time.temporal.TemporalAdjusters</code>类包含了一批有用的方法来创建TemporalAdjuster，以下是其中一部分：</p>
<ul>
<li><code>firstDayOfMonth()</code></li>
<li><code>firstDayOfNextMonth()</code></li>
<li><code>firstInMonth(DayOfWeek)</code></li>
<li><code>lastDayOfMont()</code></li>
<li><code>next(DayOfWeek)</code></li>
<li><code>nextOrSame(DayOfWeek)</code></li>
<li><code>previous(DayOfWeek)</code></li>
<li><code>previousOrSame(DayOfWeek)</code></li>
</ul>
<p>用<code>TemporalAdjuster</code>的<code>with</code>方法，该方法返回date-time或date对象调整后的副本，例如：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.time.temporal.TemporalAdjusters.*;</div><div class="line"><span class="comment">//...</span></div><div class="line">LocalDate nextTuesday = LocalDate.now().with(next(DayOfWeek.TUESDAY));</div></pre></td></tr></table></figure></p>
<h3>7.7 Instant(即时)</h3>
<p><code>Instant</code>类表示精确到纳秒的时间点，它构成了Java 8的date-time API中计算时间的基础。</p>
<p>跟老的Date类很像，<code>Instant</code>也是从&quot;纪元&quot;(1970-01-01)开始计算时间的，且不考虑时区。</p>
<h3>7.8 时区</h3>
<p>时区是用<code>java.time.ZoneId</code>类来表示的。共有两种时区标识，基于固定偏移的和基于地理区域的。这可以用来补偿类似&quot;夏令时&quot;之类复杂情况的时间。</p>
<p>可以通过很多方法来获取时区标识的实例，以下是两个示例：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ZoneId mountainTime = ZoneId.of(<span class="string">"America/Denver"</span>);</div><div class="line">ZoneId myZone = ZoneId.systemDefault();</div></pre></td></tr></table></figure></p>
<p>如果要打印所有可用的标识，可以调用<code>getAvailableZoneIds()</code>：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.println(ZoneId.getAvailableZoneIds());</div></pre></td></tr></table></figure></p>
<h3>7.9 向后兼容性</h3>
<p>原始的Date和Calendar对象包含<code>toInstant()</code>方法来转换到新的Date-Time API，可以调用<code>ofInstant(Insant,ZoneId)</code>方法来获取<code>LocalDateTime</code>或<code>ZonedDateTime</code>对象，例如：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Date date = <span class="keyword">new</span> Date();</div><div class="line">Instant now = date.toInstant();</div><div class="line">LocalDateTime dateTime = LocalDateTime.ofInstant(now, myZone);</div><div class="line">ZonedDateTime zdt = ZonedDateTime.ofInstant(now, myZone);</div></pre></td></tr></table></figure></p>
<h2>8 再也没有永久代了</h2>
<blockquote>
<p>发布的实现将把类的元数据放在本地内存，并将内部的字符串和静态类移至Java堆中。<a href="http://openjdk.java.net/jeps/122" class="uri" target="_blank" rel="external">http://openjdk.java.net/jeps/122</a></p>
</blockquote>
<p>大多数情况的类元数据内存分配现在被分配在了本地内存。这意味着不用再设置&quot;XX:PermSize&quot;选项了(实际上也没有了)。</p>
<p>这也意味着，在内存溢出的时候，你会得到&quot;java.lang.OutOfMemoryError: Metadata space&quot;的错误信息，而不是之前的&quot;java.lang.OutOfMemoryError: Permgen space&quot;</p>
<p>这是某种程度上Oracle JRockit和HotSpot两个JVM的一致性。</p>
<h2>9 杂项</h2>
<p>Java 8有大量你可能会忽略的新功能，因为你的注意了都被lambda吸引去了。以下是这些功能的部分：</p>
<ul>
<li><code>java.util.Base64</code></li>
<li>加密算法更新(很多)</li>
<li>JDBC 4.2</li>
<li>可重复的注解</li>
<li>类型的注解</li>
</ul>
<p>如果想获得更完整的列表，请参考<a href="http://openjdk.java.net/projects/jdk8/features/" target="_blank" rel="external">官方列表</a>。</p>
<h3>9.1 Base64</h3>
<p>知道现在，Java开发者必须依赖第三方库来编码和解码Base-64。由于这是个很常用的操作，大型的项目通常会包含多个不同的Base64实现。例如：Apache common-codec、Spring和Guava都有独立的实现。</p>
<p>出于这个原因，Java 8引入了<code>java.util.Base64</code>，其行为类似Base64的编码和解码器，有以下方法：</p>
<ul>
<li><code>getEncoder()</code></li>
<li><code>getDecoder()</code></li>
<li><code>getUrlEncoder()</code></li>
<li><code>getUrlDecoder()</code></li>
</ul>
<p>每个工厂方法返回编码器或者解码器。</p>
<p>URL Base64编码器提供URL和文件地址安全(62是-，63是_)的编码。</p>
<h3>9.2 Java类型的注解</h3>
<p>Java 8之前，注解可以用于任意的申明。在Java 8中，注解可以用于<em>类型的使用</em>，以下是一些示例：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Class instance creation:</span></div><div class="line"><span class="keyword">new</span> <span class="annotation">@Interned</span> RocketShip();</div><div class="line"></div><div class="line"><span class="comment">// Type cast:</span></div><div class="line">notNullString = (<span class="annotation">@NonNull</span> String) str;</div><div class="line"></div><div class="line"><span class="comment">// implements clause:</span></div><div class="line">class ImmutableSet&lt;T&gt; implements</div><div class="line">        <span class="annotation">@Readonly</span> Set&lt;<span class="annotation">@Readonly</span> T&gt; { ... }</div><div class="line"></div><div class="line"><span class="comment">// Thrown exception declaration:</span></div><div class="line"><span class="keyword">void</span> launchRocket() <span class="keyword">throws</span></div><div class="line">   	<span class="annotation">@Critical</span> FireException { ... }</div></pre></td></tr></table></figure></p>
<p>新功能注意目标在于支持类型检查的框架，如<a href="http://types.cs.washington.edu/checker-framework/" target="_blank" rel="external">Checker</a>。这些框架在编译期就可以协助找到代码中的错误。</p>
<h3>9.3 可重复的注解</h3>
<p>Java 8允许使用<code>@Repeatable</code>注解的注解重复使用。</p>
<p>例如，假设你在编写一个游戏，并且想使用注解来调度方法何时被调用，你可以使用多个注解申明多个调度策略：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// the first of the month and every monday at 7am</span></div><div class="line"><span class="annotation">@Schedule</span>(dayOfMonth=<span class="string">"first"</span>)</div><div class="line"><span class="annotation">@Schedule</span>(dayOfWeek=<span class="string">"Monday"</span>, hour=<span class="number">7</span>)</div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGoblinInvasion</span>() { ... }</div></pre></td></tr></table></figure></p>
<p>为了将这些变得可能，你需要：</p>
<ul>
<li><code>Schedule</code>注解需要使用元注解<code>@Repeatable</code>。</li>
<li>需要另一个注解通过<code>@Repeatable</code>注解来申明。</li>
</ul>
<p>由于Java注重向后兼容性，重复的注解实际上是和另一个注解(即你的注解)一起保存的。<code>@Repeatable</code>注解的输入是一个包含注解的类，例如：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Schedule.java</span></div><div class="line"><span class="annotation">@Repeatable</span>(Schedules.class)</div><div class="line"><span class="keyword">public</span> @<span class="class"><span class="keyword">interface</span> <span class="title">Schedule</span> </span>{...}</div><div class="line"><span class="comment">// Schedules.java</span></div><div class="line"><span class="keyword">public</span> @<span class="class"><span class="keyword">interface</span> <span class="title">Schedules</span> </span>{</div><div class="line">    Schedule[] value;</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>现在Schedule就是一个<code>可重复的注解</code>。</p>
<p>可以使用反射在运行期访问可重复的注解。完成这些的新方法是<code>getAnnotationsByType</code>(Class annotationClass)，在<code>Class</code>、<code>Constructor</code>和<code>Method</code>等上都有。他返回所有这样注解的数组(如果没有的话，返回空数组)。</p>
<h2>10 Java 8中的函数式编程</h2>
<p>Java 8计划添加很多函数式语言的特性却不很显著的改动Java语言。</p>
<p>当lambda表达式、方法引用、Stream接口和不可变的数据类型结合在一起，Java就可以进行所谓的&quot;函数式编程&quot;(“functional programming” (FP))了。</p>
<p>处于本书的目的，函数式编程的三大支柱是：</p>
<ul>
<li>函数</li>
<li>不可变性</li>
<li>并发性</li>
</ul>
<h3>10.1 函数</h3>
<p>当然，如其名所示，函数式编程是基于函数是第一类型的特性。Java 8可以说通过Lambda项目和<em>函数接口</em>把函数提升到了第一类型。</p>
<p><code>Function</code>接口(包括相关的接口<code>IntFunction</code>、<code>DoubleFunction</code>、<code>LongFunction</code>、<code>BiFunction</code>等)体现了Java 8在提升函数到对象过程中做出的妥协。该接口允许函数像参数一样传递，像变量一样保存，以及可以由方法返回。</p>
<p><code>Function</code>接口有以下默认方法：</p>
<ul>
<li><code>andThen(Function)</code>: 返回一个合成函数，该函数先在输入上调用本函数，在在结果上调用给定的函数。</li>
<li><code>compose(Function)</code>: 和<code>andThen</code>类似，但是顺序不一样(即，先在输入上调用给定的函数，再调用本函数)。</li>
<li><code>identity()</code>: 返回一个函数，该函数总是返回其输入值。</li>
</ul>
<p>你可以使用这些方法来创建一个创建函数的链，例如：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Function&lt;Integer,String&gt; f = Function.&lt;Integer&gt;identity()</div><div class="line">        .andThen(i -&gt; <span class="number">2</span>*i).andThen(i -&gt; <span class="string">"str"</span> + i);</div></pre></td></tr></table></figure></p>
<p>返回的函数输入一个整数，乘以2，然后在前面添加&quot;str&quot;。</p>
<p>可以使用<code>andThen</code>任意多次来创建一个函数，记住，函数可以被传递进和返回自方法。以下是一个使用新的Date-Time API的例子：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Function&lt;LocalDate,LocalDateTime&gt; <span class="title">dateTimeFunction</span>(</div><div class="line">    <span class="keyword">final</span> Function&lt;LocalDate,LocalDate&gt; f) {</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> f.andThen(d -&gt; d.atTime(<span class="number">2</span>, <span class="number">2</span>));</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>该方法输入是一个操作<code>LocalDate</code>的函数，并转换为输出<code>LocalDateTime</code>(在时间上午<code>02:02</code>)的函数。</p>
<p><strong>Tuple(元组)</strong></p>
<p>如果需要一个有多于两个参数方法的函数接口(如，&quot;TriFunction&quot;)，那么你需要使用库自己生成。另一个处理这个问题的方法是使用一个叫<em>Tuple</em>的数据结构。</p>
<p>Tuple是一个有类型的数据结构，用于保存一列元素。一些语言，如Scala，对Tuple有内建的支持。Tuple在处理多个相关的值，但却不希望有创建新类的开销的时候很有用。</p>
<p>以下一个非常简单的实现两个元素Tuple的例子：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple2</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt; </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> A _1;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> B _2;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="title">Tuple2</span>(A a, B b) {</div><div class="line">            <span class="keyword">this</span>._1 = a;</div><div class="line">            <span class="keyword">this</span>._2 = b;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> A <span class="title">get_1</span>() {</div><div class="line">            <span class="keyword">return</span> _1;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> B <span class="title">get_2</span>() {</div><div class="line">            <span class="keyword">return</span> _2;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>元组也能让你近似返回多个值。</p>
<blockquote>
<p>Java中有多个可用的Tuple的实现，例如<a href="http://www.javatuples.org/" target="_blank" rel="external">javatuples</a>和<a href="https://code.google.com/p/totallylazy/" target="_blank" rel="external">totallylazy</a>。</p>
</blockquote>
<h3>10.2 不可变性</h3>
<p>在函数式编程中，状态被认为是有害的，需要尽可能去避免，相反，<em>immutable</em>(不可变的)数据结构很受推荐。例如，<code>String</code>就是Java中的一个不可变类型。</p>
<p>正如你所知，Java 8的新Date-Time类是不可变的。而你可能没有意识到的是，<em>几乎所有</em>新加入Java 8的类都是不可变的(如Optional和Stream)。</p>
<p>然而，在使用Java 8的函数式模式的时候，必须小心防止又陷入可变模式的思维定势。例如，以下代码是应当避免的：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[] myCount = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</div><div class="line">list.forEach(dragon -&gt; {</div><div class="line">    <span class="keyword">if</span> (dragon.isGreen()) myCount[<span class="number">0</span>]++;</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>虽然你可能很聪明，但是这样的代码会导致问题，相反，你应该使用类似下面的做法：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">list.stream().filter(Dragon::isGreen).count();</div></pre></td></tr></table></figure></p>
<p>如果发现你自己又要求助于可变性的时候，考虑是否可以使用“filter”、“map”、“reduce”和“collect”的结合做替代。</p>
<h3>10.3 并发性</h3>
<p>由于多核处理器越来越普及，并发编程变得更加重要。函数式编程为并发编程创建了坚实的基础，Java 8也使用多种方式支持并发性。</p>
<p>第一种方式是Collection的<code>parallelStream()</code>方法。它提供了一条并发使用Stream的捷径，然而，和所有优化一样，你需要测试来确认代码实际上变得更快了，并保守是使用它。太多的并发性，实际上会导致程序变慢。</p>
<p>第二种Java 8支持并发的方式是使用新的<code>CompletableFuture</code>类。它包含<code>supplyAsync</code>静态方法，其输入是函数接口<code>Supplier</code>(生产者)；它还包含方法<code>thenAccept</code>，其输入是<code>Consumer</code>(消费者)，用于处理任务的完成。<code>CompletableFuture</code>在另一个线程中调用给定的<code>Supplier</code>，并在完成时执行<code>Consumer</code>。</p>
<p>当和类似<code>CountDownLatch</code>、<code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicReference</code>等的类连接起来，就可以实现线程安全，并发的类似函数式的代码，例如：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Dragon <span class="title">closestDragon</span>(Location location) {</div><div class="line">    AtomicReference&lt;DragonDistance&gt; closest = </div><div class="line">        <span class="keyword">new</span> AtomicReference&lt;&gt;(DragonDistance.worstMatch());</div><div class="line">    CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(dragons.size());</div><div class="line">    dragons.forEach(dragon -&gt; {</div><div class="line">        CompletableFuture.supplyAsync(() -&gt; dragon.distance(location))</div><div class="line">          .thenAccept(result -&gt; {</div><div class="line">            closest.accumulateAndGet(result, DragonDistance::closest);</div><div class="line">            latch.countDown();</div><div class="line">            });</div><div class="line">        });</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        latch.await();</div><div class="line">    } <span class="keyword">catch</span> (InterruptedException e) {</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Interrupted during calculations"</span>, e);</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> closest.get().getDragon();</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>上例找到最近的龙的位置(假设Dragon的<code>distance</code>方法会导致耗时的计算)。</p>
<p>然而，这可以用<code>parallelStream()</code>默认方法来简化(因为过程中只有一种计算)，如下所示：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Dragon <span class="title">closestDragon</span>(Location location) {</div><div class="line">    <span class="keyword">return</span> dragons.parallelStream()</div><div class="line">      .map(dragon -&gt; dragon.distance(location))</div><div class="line">      .reduce(DistancePair.worstMatch(), DragonDistance::closest)</div><div class="line">      .getDragon();</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>以上代码进行了和之前的例子实质上相同的任务，但是更加简洁(函数式)。</p>
<h3>10.4 尾调用优化</h3>
<p>函数式编程的一个标志是<em>尾调用递归</em><a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a>。它用迭代的方式(函数式编程中没有迭代)处理相同的问题，不幸的是，如果没有编译器适当的优化，它会导致栈溢出。</p>
<p><em>尾调用优化</em>指编译器将递归的函数调用转化为循环来避免栈溢出。例如，Lisp中使用尾调用递归的函数会自动进行这样的优化。</p>
<p>Java 8和很多其他语言一样不支持尾调用优化(目前为止)。然而，使用类似下面这样的接口来预估是可能的：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Tail</span>&lt;<span class="title">T</span>&gt; </span>{</div><div class="line"></div><div class="line">    Tail&lt;T&gt; apply();</div><div class="line"></div><div class="line">    <span class="keyword">default</span> <span class="keyword">boolean</span> isDone() {</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">default</span> T result() {</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Not done yet."</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">default</span> T invoke() {</div><div class="line">        <span class="keyword">return</span> Stream.iterate(<span class="keyword">this</span>, Tail::apply)</div><div class="line">                .filter(Tail::isDone)</div><div class="line">                .findFirst()</div><div class="line">                .get()</div><div class="line">                .result();</div><div class="line">    }</div></pre></td></tr></table></figure></p>
<p><code>Tail</code>接口有3个默认方法和1个抽象方法(<code>apply</code>)，<code>invoke()</code>方法包含了&quot;尾调用优化&quot;的主体：</p>
<ul>
<li>它使用了Stream的<code>iterate</code>方法带来的便利来创建无限Stream，这回持续的调用尾的<code>apply</code>方法。</li>
<li>然后，直到<code>isDone()</code>返回真的时候，调用<code>filter</code>和<code>findFirst</code>来停止Stream。</li>
<li>最后，返回结果。</li>
</ul>
<p>为了实现&quot;完成&quot;条件，Tail需要有以下额外的静态方法：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> &lt;T&gt; Tail&lt;T&gt; done(<span class="keyword">final</span> T value) {</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Tail&lt;T&gt;() {</div><div class="line">        <span class="annotation">@Override</span></div><div class="line">        <span class="keyword">public</span> T <span class="title">result</span>() {</div><div class="line">          <span class="keyword">return</span> value;</div><div class="line">        }  </div><div class="line">        <span class="annotation">@Override</span></div><div class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDone</span>() {</div><div class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        }</div><div class="line">        <span class="annotation">@Override</span></div><div class="line">        <span class="keyword">public</span> Tail&lt;T&gt; <span class="title">apply</span>() {</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Not supported."</span>);</div><div class="line">        }</div><div class="line">    };</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>使用<code>Tail</code>接口，你就可以在Java 8中轻易的模拟尾调用递归。以下是使用这个接口计算<em>阶乘</em>的示例：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">fastFactorial</span>(<span class="keyword">int</span> n) {</div><div class="line">    <span class="keyword">return</span> fastFactorial(<span class="number">1</span>L, n).invoke();</div><div class="line">}</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Tail&lt;Long&gt; <span class="title">fastFactorial</span>(<span class="keyword">long</span> x, <span class="keyword">int</span> n) {</div><div class="line">    <span class="keyword">return</span> () -&gt; {</div><div class="line">        <span class="keyword">switch</span> (n) {</div><div class="line">            <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">                <span class="keyword">return</span> Tail.done(x);</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">return</span> fastFactorial(x * n, n - <span class="number">1</span>);</div><div class="line">        }</div><div class="line">    };</div><div class="line">}</div></pre></td></tr></table></figure></p>
<p>使用这个方法，就可以获取极快的程序运行速度而仍然使用函数式风格。</p>
<p>当然，JVM本身已经做了很多优化，因此这可能不总是最佳的方法。但是，这值得记在脑子里。</p>
<h2>11 结论</h2>
<p>感谢你阅读了这个Java 8的简短介绍。希望你已经学到很多，并已经准备好开始自己使用。</p>
<p>综上，Java 8包含以下特性：</p>
<ul>
<li>lambda表达式</li>
<li>方法引用</li>
<li>默认方法(Defender方法)</li>
<li>新的Stream API</li>
<li>Optional</li>
<li>新的Date/Time API</li>
<li>新的JavaScript引擎Nashorn</li>
<li>移除永久代</li>
</ul>
<p>如果要更总Java未来可能的加入的特性，可能需要参考<a href="http://openjdk.java.net/jeps/0" target="_blank" rel="external">JEPS</a></p>
<h2>反向移植</h2>
<p>如果处于一些原因无法立即更新到Java 8。也有一些方法反向移植一些Java 8的特性到之前版本。</p>
<p>对每个特性，以下是反向移植或类似的库：</p>
<ul>
<li>Lambdas – <a href="https://github.com/orfjackal/retrolambda" target="_blank" rel="external">Retrolambda</a></li>
<li>Lazily Evaluated Sequences – <a href="https://code.google.com/p/totallylazy/" target="_blank" rel="external">totallylazy</a></li>
<li>Optional – <a href="https://code.google.com/p/guava-libraries/" target="_blank" rel="external">guava</a></li>
<li>Date/Time – <a href="http://www.threeten.org/" target="_blank" rel="external">ThreeTen</a></li>
<li>Nashorn – <a href="https://bitbucket.org/ramonza/nashorn-backport" target="_blank" rel="external">nashorn-backport</a></li>
</ul>
<p>请谨慎使用反向移植。</p>
<div class="footnotes">
<hr>
<ol>
<li id="fn1"><p>译者注：本文原地址在<a href="https://leanpub.com/whatsnewinjava8/read" class="uri" target="_blank" rel="external">https://leanpub.com/whatsnewinjava8/read</a><a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>译者注：这里指Optional类<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>lambda表达式<em>不是</em>匿名类，实际上它在字节码中使用了<code>invokedynamic</code>(译者注：动态调用)。<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>下一节中介绍&quot;函数接口&quot;的含义。<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>当然，你这里需要加一个<code>catch</code>语句处理异常。<a href="#fnref5">↩</a></p></li>
<li id="fn6"><p>实际的方法签名是<code>walk(Path start, FileVisitOption... options)</code>，但是可能用<code>walk(Path start)</code>就可以。<a href="#fnref6">↩</a></p></li>
<li id="fn7"><p>尾调用递归是一个函数的调用作为这个函数的最后动作发生。<a href="#fnref7">↩</a></p></li>
</ol>
</div>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/Java/">Java</a><a href="/tags/Translation/">Translation</a>
  </div>


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Java/">Java</a>
</div>



<div class="article-share" id="share">

  <div data-url="http://valleylord.github.io/post/201411-java-new-features/" data-title="Java 8新特性(What&#39;s New in Java 8 中文翻译版) | 褚哥说|" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/post/201411-postgres-rpm/" title="PostgreSQL的rpm打包">
  <strong>PREVIOUS:</strong><br/>
  <span>
  PostgreSQL的rpm打包</span>
</a>
</div>


<div class="next">
<a href="/post/201411-postgres-mv/"  title="PostgreSQL物化视图简介">
 <strong>NEXT:</strong><br/> 
 <span>PostgreSQL物化视图简介
</span>
</a>
</div>

</nav>

	
</div>  
      
  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">2.</span> <span class="toc-text">1 概览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">3.</span> <span class="toc-text">2 lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">3.1.</span> <span class="toc-text">2.1 语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">3.2.</span> <span class="toc-text">2.2 范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">3.3.</span> <span class="toc-text">2.3 方法引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">3.4.</span> <span class="toc-text">2.4 函数接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">3.5.</span> <span class="toc-text">2.5 与Java 7的比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">4.</span> <span class="toc-text">3 默认方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">4.1.</span> <span class="toc-text">3.1 默认的和函数的(接口)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">4.2.</span> <span class="toc-text">3.2 多个默认方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">4.3.</span> <span class="toc-text">3.3 接口中的静态方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">5.</span> <span class="toc-text">4 Stream(流)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">5.1.</span> <span class="toc-text">4.1 什么是Stream？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">5.2.</span> <span class="toc-text">4.2 生成Stream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">5.3.</span> <span class="toc-text">4.3 For Each</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">5.4.</span> <span class="toc-text">4.4 Map/Filter/Reduce</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">5.5.</span> <span class="toc-text">4.5 Parallel Array(并行数组)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">5.6.</span> <span class="toc-text">4.6 Peek(偷看)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">5.7.</span> <span class="toc-text">4.7 Limit(限制)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">5.8.</span> <span class="toc-text">4.8 Sort(排序)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">5.9.</span> <span class="toc-text">4.9 Collector(收集器)和统计量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">5.10.</span> <span class="toc-text">4.10 分组和分块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">5.11.</span> <span class="toc-text">4.11 与Java 7的比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">6.</span> <span class="toc-text">5 Optional类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">7.</span> <span class="toc-text">6 Nashorn</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">7.1.</span> <span class="toc-text">6.1 jjs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">7.2.</span> <span class="toc-text">6.2 脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">7.3.</span> <span class="toc-text">6.3 脚本引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">7.4.</span> <span class="toc-text">6.4 引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">7.5.</span> <span class="toc-text">6.5 扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">7.6.</span> <span class="toc-text">6.6 Invocable</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">8.</span> <span class="toc-text">7 新的Date和Time API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">8.1.</span> <span class="toc-text">7.1 新的类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">8.2.</span> <span class="toc-text">7.2 创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">8.3.</span> <span class="toc-text">7.3 枚举类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">8.4.</span> <span class="toc-text">7.4 Clock(时钟)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">8.5.</span> <span class="toc-text">7.5 时间区间和时间长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">8.6.</span> <span class="toc-text">7.6 时间调整(TemporalAdjusters)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">8.7.</span> <span class="toc-text">7.7 Instant(即时)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">8.8.</span> <span class="toc-text">7.8 时区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">8.9.</span> <span class="toc-text">7.9 向后兼容性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">9.</span> <span class="toc-text">8 再也没有永久代了</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">10.</span> <span class="toc-text">9 杂项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">10.1.</span> <span class="toc-text">9.1 Base64</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">10.2.</span> <span class="toc-text">9.2 Java类型的注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">10.3.</span> <span class="toc-text">9.3 可重复的注解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">11.</span> <span class="toc-text">10 Java 8中的函数式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">11.1.</span> <span class="toc-text">10.1 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">11.2.</span> <span class="toc-text">10.2 不可变性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">11.3.</span> <span class="toc-text">10.3 并发性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">11.4.</span> <span class="toc-text">10.4 尾调用优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">12.</span> <span class="toc-text">11 结论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">13.</span> <span class="toc-text">反向移植</span></a></li></ol>
  </div>

<div id="asidepart">
<div id="authorInfo">
	
		<div class="author-logo"></div>		
	
	
	<section class="author-info">
		
			<p> 欢迎来到Valleylord的博客！</p>
		
		
			<p>	本博的文章尽量原创。</p>
		
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/http://weibo.com/valleylord" target="_blank" title="weibo"></a>
		
		
		
		<a href="https://github.com/https://github.com/valleylord" target="_blank" title="github"></a>
		
		
	</div>
</div>
<aside class="clearfix">


  
  <div class="archiveslist">
    <p class="asidetitle"><a href="/archives">归档</a></p>
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">November 2014</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">October 2014</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09/">September 2014</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/08/">August 2014</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/05/">May 2014</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04/">April 2014</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/02/">February 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2000/01/">January 2000</a><span class="archive-list-count">1</span></li></ul>
  </div>


  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
			<li><a href="/categories/Blog/" title="Blog">Blog<sup>1</sup></a></li>
		
			<li><a href="/categories/C/" title="C++">C++<sup>3</sup></a></li>
		
			<li><a href="/categories/Dataguru/" title="Dataguru">Dataguru<sup>3</sup></a></li>
		
			<li><a href="/categories/Docker/" title="Docker">Docker<sup>7</sup></a></li>
		
			<li><a href="/categories/FP/" title="FP">FP<sup>2</sup></a></li>
		
			<li><a href="/categories/JVM/" title="JVM">JVM<sup>10</sup></a></li>
		
			<li><a href="/categories/Java/" title="Java">Java<sup>1</sup></a></li>
		
			<li><a href="/categories/Kubernetes/" title="Kubernetes">Kubernetes<sup>3</sup></a></li>
		
			<li><a href="/categories/Linux/" title="Linux">Linux<sup>1</sup></a></li>
		
			<li><a href="/categories/MyCAT/" title="MyCAT">MyCAT<sup>5</sup></a></li>
		
			<li><a href="/categories/Postgres/" title="Postgres">Postgres<sup>18</sup></a></li>
		
			<li><a href="/categories/REPL/" title="REPL">REPL<sup>1</sup></a></li>
		
			<li><a href="/categories/other/" title="other">other<sup>1</sup></a></li>
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/Blog/" title="Blog">Blog<sup>1</sup></a></li>
		
			<li><a href="/tags/C/" title="C++">C++<sup>3</sup></a></li>
		
			<li><a href="/tags/C-11/" title="C++11">C++11<sup>1</sup></a></li>
		
			<li><a href="/tags/Dataguru/" title="Dataguru">Dataguru<sup>47</sup></a></li>
		
			<li><a href="/tags/Docker/" title="Docker">Docker<sup>7</sup></a></li>
		
			<li><a href="/tags/Hexo/" title="Hexo">Hexo<sup>1</sup></a></li>
		
			<li><a href="/tags/JVM/" title="JVM">JVM<sup>10</sup></a></li>
		
			<li><a href="/tags/Java/" title="Java">Java<sup>11</sup></a></li>
		
			<li><a href="/tags/Kubernetes/" title="Kubernetes">Kubernetes<sup>3</sup></a></li>
		
			<li><a href="/tags/Linux/" title="Linux">Linux<sup>1</sup></a></li>
		
			<li><a href="/tags/MyCAT/" title="MyCAT">MyCAT<sup>5</sup></a></li>
		
			<li><a href="/tags/Postgres/" title="Postgres">Postgres<sup>18</sup></a></li>
		
			<li><a href="/tags/Quantmod/" title="Quantmod">Quantmod<sup>3</sup></a></li>
		
			<li><a href="/tags/R/" title="R">R<sup>3</sup></a></li>
		
			<li><a href="/tags/REPL/" title="REPL">REPL<sup>1</sup></a></li>
		
			<li><a href="/tags/SICP/" title="SICP">SICP<sup>2</sup></a></li>
		
			<li><a href="/tags/Tomcat/" title="Tomcat">Tomcat<sup>1</sup></a></li>
		
			<li><a href="/tags/Translation/" title="Translation">Translation<sup>2</sup></a></li>
		
			<li><a href="/tags/boost/" title="boost">boost<sup>1</sup></a></li>
		
			<li><a href="/tags/quantlib/" title="quantlib">quantlib<sup>1</sup></a></li>
		
		</ul>
</div>


  
  <div class="tagcloudlist">
    <p class="asidetitle">标签云</p>
    <div class="tagcloudlist clearfix">
       <a href="/tags/Blog/" style="font-size: 10.00px;">Blog</a><a href="/tags/C/" style="font-size: 12.50px;">C++</a><a href="/tags/C-11/" style="font-size: 10.00px;">C++11</a><a href="/tags/Dataguru/" style="font-size: 20.00px;">Dataguru</a><a href="/tags/Docker/" style="font-size: 15.00px;">Docker</a><a href="/tags/Hexo/" style="font-size: 10.00px;">Hexo</a><a href="/tags/JVM/" style="font-size: 16.25px;">JVM</a><a href="/tags/Java/" style="font-size: 17.50px;">Java</a><a href="/tags/Kubernetes/" style="font-size: 12.50px;">Kubernetes</a><a href="/tags/Linux/" style="font-size: 10.00px;">Linux</a><a href="/tags/MyCAT/" style="font-size: 13.75px;">MyCAT</a><a href="/tags/Postgres/" style="font-size: 18.75px;">Postgres</a><a href="/tags/Quantmod/" style="font-size: 12.50px;">Quantmod</a><a href="/tags/R/" style="font-size: 12.50px;">R</a><a href="/tags/REPL/" style="font-size: 10.00px;">REPL</a><a href="/tags/SICP/" style="font-size: 11.25px;">SICP</a><a href="/tags/Tomcat/" style="font-size: 10.00px;">Tomcat</a><a href="/tags/Translation/" style="font-size: 11.25px;">Translation</a><a href="/tags/boost/" style="font-size: 10.00px;">boost</a><a href="/tags/quantlib/" style="font-size: 10.00px;">quantlib</a><a href="/tags/scheme/" style="font-size: 11.25px;">scheme</a><a href="/tags/shipyard/" style="font-size: 10.00px;">shipyard</a>
    </div>
  </div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
      <!--
      <li><a href="http://yangjian.me" target="_blank" title="YangJian">Alimon's Blog</a></li>
      <li><a href="http://zespia.tw/hexo" target="_blank" title="Hexo">Hexo</a></li>
      -->
    </ul>
</div>

  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >

</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  //back to top
  function backToTop(){
    var buttonHTML = $("<a href=\"#top\" id=\"back-top\">" + "<span>Back to Top</span></a>");
    buttonHTML.appendTo($("body"));
    var buttonToTop = $("#back-top");
    // hide #back-top first
    buttonToTop.hide();

    // fade in #back-top
    $(function() {
        $(window).scroll(function() {
            if ($(this).scrollTop() > 200) {
                buttonToTop.fadeIn();
            } else {
                buttonToTop.fadeOut();
            }
        });
        // scroll body to 0px on click
        buttonToTop.click(function() {
            $('body,html').animate({
                scrollTop: 0
            }, 800);
            return false;
        });
    });
  }
  backToTop();

  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      ta = $('#toc.toc-aside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });

  var show = true;
  c.click(function(){
    if(show == true){
        a.addClass('fadeOut').css('display', 'none');
        ta.css('display', 'block').addClass('fadeIn');
        m.addClass('moveMain');  
    }else{
        a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');     
        ta.css('display', 'none'); 
        m.removeClass('moveMain');
        $('#toc.toc-aside').css('display', 'none');
    }
    show = !show;
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{

    $(window).scroll(function(){
      ta.css("top",Math.max(140,240-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
